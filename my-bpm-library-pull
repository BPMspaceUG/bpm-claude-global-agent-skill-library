#!/usr/bin/env bash
#
# my-bpm-library-pull - Pull my-bpm-prefixed items from the Git repository to local ~/.claude/
#
# Usage:
#   my-bpm-library-pull                  Pull all my-bpm-items
#   my-bpm-library-pull --dry-run        Show what would change
#   my-bpm-library-pull --force          Overwrite even on conflicts (repo wins)
#   my-bpm-library-pull --only-skills    Pull only skills
#   my-bpm-library-pull --verbose        Show detailed output
#
# Requires: git

set -euo pipefail

VERSION="1.1.0"
REPO_NAME="bpm-claude-global-agent-skill-library"
REPO_URL="git@github.com:BPMspaceUG/bpm-claude-global-agent-skill-library.git"
REPO_DIR="$HOME/$REPO_NAME"

# Defaults
DRY_RUN=0
VERBOSE=0
FORCE=0
ONLY_SKILLS=0
ONLY_AGENTS=0
ONLY_COMMANDS=0
ONLY_RUNBOOKS=0

# Categories to sync
CATEGORIES=(skills agents commands runbooks)

# Determine target directory (check which one Claude Code actually uses)
get_target_dir() {
  # Prefer the directory that has settings.json (= actively used by Claude Code)
  if [[ -f "$HOME/.claude/settings.json" ]]; then
    echo "$HOME/.claude"
  elif [[ -f "$HOME/.config/claude/settings.json" ]]; then
    echo "$HOME/.config/claude"
  elif [[ -d "$HOME/.claude" ]]; then
    echo "$HOME/.claude"
  elif [[ -d "$HOME/.config/claude" ]]; then
    echo "$HOME/.config/claude"
  else
    echo "$HOME/.claude"
  fi
}

log_verbose() {
  if [[ "$VERBOSE" -eq 1 ]]; then
    echo "[DEBUG] $*" >&2
  fi
}

# --- Sync state management (conflict detection) ---

declare -A SYNC_STATE

# Compute a deterministic hash for a file or directory
compute_item_hash() {
  local path="$1"
  if [[ -d "$path" ]]; then
    (cd "$path" && find . -type f -print0 | sort -z | xargs -0 sha256sum 2>/dev/null | sha256sum | cut -d' ' -f1)
  elif [[ -f "$path" ]]; then
    sha256sum "$path" | cut -d' ' -f1
  else
    echo ""
  fi
}

load_sync_state() {
  local sync_file="$1"
  SYNC_STATE=()
  [[ -f "$sync_file" ]] || return 0
  while IFS=' ' read -r hash key; do
    [[ -z "$hash" || "$hash" == "#"* ]] && continue
    SYNC_STATE["$key"]="$hash"
  done < "$sync_file"
  log_verbose "Loaded ${#SYNC_STATE[@]} sync baselines"
}

get_sync_hash() {
  echo "${SYNC_STATE[$1]:-}"
}

set_sync_hash() {
  SYNC_STATE["$1"]="$2"
}

save_sync_state() {
  local sync_file="$1"
  [[ "$DRY_RUN" -eq 1 ]] && return 0
  : > "$sync_file"
  for key in $(echo "${!SYNC_STATE[@]}" | tr ' ' '\n' | sort); do
    echo "${SYNC_STATE[$key]} $key" >> "$sync_file"
  done
  log_verbose "Saved ${#SYNC_STATE[@]} sync baselines"
}

# --- End sync state ---

show_help() {
  echo "my-bpm-library-pull v$VERSION - Pull my-bpm-items from repo to local"
  echo ""
  echo "Usage:"
  echo "  my-bpm-library-pull                  Pull all my-bpm-items"
  echo "  my-bpm-library-pull --dry-run        Show what would change without applying"
  echo "  my-bpm-library-pull --force          Overwrite even on conflicts (repo wins)"
  echo "  my-bpm-library-pull --verbose        Show detailed output"
  echo "  my-bpm-library-pull --only-skills    Pull only skills"
  echo "  my-bpm-library-pull --only-agents    Pull only agents"
  echo "  my-bpm-library-pull --only-commands  Pull only commands"
  echo "  my-bpm-library-pull --only-runbooks  Pull only runbooks"
  echo "  my-bpm-library-pull --version        Show version"
  echo "  my-bpm-library-pull --help           Show this help"
}

# Parse arguments
for arg in "$@"; do
  case "$arg" in
    --dry-run)       DRY_RUN=1 ;;
    --verbose)       VERBOSE=1 ;;
    --force)         FORCE=1 ;;
    --only-skills)   ONLY_SKILLS=1 ;;
    --only-agents)   ONLY_AGENTS=1 ;;
    --only-commands) ONLY_COMMANDS=1 ;;
    --only-runbooks) ONLY_RUNBOOKS=1 ;;
    -v|--version)    echo "my-bpm-library-pull v$VERSION"; exit 0 ;;
    -h|--help)       show_help; exit 0 ;;
    *)               echo "Unknown option: $arg"; show_help; exit 1 ;;
  esac
done

# Determine which categories to process
if [[ "$ONLY_SKILLS" -eq 1 ]] || [[ "$ONLY_AGENTS" -eq 1 ]] || [[ "$ONLY_COMMANDS" -eq 1 ]] || [[ "$ONLY_RUNBOOKS" -eq 1 ]]; then
  CATEGORIES=()
  [[ "$ONLY_SKILLS" -eq 1 ]] && CATEGORIES+=("skills")
  [[ "$ONLY_AGENTS" -eq 1 ]] && CATEGORIES+=("agents")
  [[ "$ONLY_COMMANDS" -eq 1 ]] && CATEGORIES+=("commands")
  [[ "$ONLY_RUNBOOKS" -eq 1 ]] && CATEGORIES+=("runbooks")
fi

TARGET_DIR="$(get_target_dir)"
SYNC_STATE_FILE="$TARGET_DIR/.my-bpm-library-sync"

log_verbose "Target directory: $TARGET_DIR"
log_verbose "Sync state file: $SYNC_STATE_FILE"
log_verbose "Categories: ${CATEGORIES[*]}"

load_sync_state "$SYNC_STATE_FILE"

echo "my-bpm-library-pull v$VERSION"
echo ""

# Step 1: Ensure repo clone exists
if [[ ! -d "$REPO_DIR/.git" ]]; then
  echo "Repository not found at $REPO_DIR"
  if [[ "$DRY_RUN" -eq 1 ]]; then
    echo "Would clone: $REPO_URL -> $REPO_DIR"
    echo ""
    echo "DRY RUN - Run without --dry-run to clone and pull"
    exit 0
  fi
  echo "Cloning $REPO_URL..."
  git clone "$REPO_URL" "$REPO_DIR"
  echo ""
fi

# Step 2: Pull latest changes
cd "$REPO_DIR"
echo "Updating repository..."
if ! git pull --ff-only 2>/dev/null; then
  echo "WARNING: Fast-forward pull failed. Local changes may exist."
  echo "         Resolve manually: cd $REPO_DIR && git status"
  echo ""
fi

# Step 3: Check for my/ directory in repo
if [[ ! -d "$REPO_DIR/my" ]]; then
  echo "No my/ directory found in repository."
  echo "Nothing to pull."
  exit 0
fi

# Step 4: Compare and sync each category
NEW_COUNT=0
MODIFIED_COUNT=0
UNCHANGED_COUNT=0
CONFLICT_COUNT=0

for category in "${CATEGORIES[@]}"; do
  REPO_CAT_DIR="$REPO_DIR/my/$category"

  if [[ ! -d "$REPO_CAT_DIR" ]]; then
    log_verbose "No my/$category directory in repo, skipping"
    continue
  fi

  # Determine local target based on category
  LOCAL_CAT_DIR="$TARGET_DIR/$category"
  mkdir -p "$LOCAL_CAT_DIR"

  log_verbose "Processing category: $category"
  log_verbose "  Repo:  $REPO_CAT_DIR"
  log_verbose "  Local: $LOCAL_CAT_DIR"

  # Handle skills (directories with SKILL.md)
  if [[ "$category" == "skills" ]]; then
    for item_dir in "$REPO_CAT_DIR"/my-*/; do
      [[ -d "$item_dir" ]] || continue
      item_name=$(basename "$item_dir")
      local_item="$LOCAL_CAT_DIR/$item_name"
      item_key="$category/$item_name"

      if [[ ! -d "$local_item" ]]; then
        echo "  + $item_key (new)"
        ((NEW_COUNT++)) || true
        if [[ "$DRY_RUN" -eq 0 ]]; then
          cp -r "$item_dir" "$local_item"
          set_sync_hash "$item_key" "$(compute_item_hash "$local_item")"
        fi
      elif ! diff -rq "$item_dir" "$local_item" > /dev/null 2>&1; then
        # Items differ — check for conflict
        baseline_hash=$(get_sync_hash "$item_key")
        if [[ -n "$baseline_hash" ]]; then
          local_hash=$(compute_item_hash "$local_item")
          repo_hash=$(compute_item_hash "$item_dir")
          local_changed=0
          repo_changed=0
          [[ "$local_hash" != "$baseline_hash" ]] && local_changed=1
          [[ "$repo_hash" != "$baseline_hash" ]] && repo_changed=1

          if [[ "$local_changed" -eq 1 ]] && [[ "$repo_changed" -eq 1 ]]; then
            if [[ "$FORCE" -eq 1 ]]; then
              echo "  ~ $item_key (CONFLICT resolved: --force, repo wins)"
              ((MODIFIED_COUNT++)) || true
              if [[ "$DRY_RUN" -eq 0 ]]; then
                rm -rf "$local_item"
                cp -r "$item_dir" "$local_item"
                set_sync_hash "$item_key" "$(compute_item_hash "$local_item")"
              fi
            else
              echo "  X $item_key (CONFLICT: changed locally AND in repo)"
              ((CONFLICT_COUNT++)) || true
            fi
            continue
          fi
        fi
        # No conflict (only one side changed, or no baseline yet)
        echo "  ~ $item_key (modified)"
        ((MODIFIED_COUNT++)) || true
        if [[ "$DRY_RUN" -eq 0 ]]; then
          rm -rf "$local_item"
          cp -r "$item_dir" "$local_item"
          set_sync_hash "$item_key" "$(compute_item_hash "$local_item")"
        fi
      else
        ((UNCHANGED_COUNT++)) || true
        log_verbose "  = $item_key (unchanged)"
        # Record baseline for unchanged items if not yet tracked
        if [[ -z "$(get_sync_hash "$item_key")" ]] && [[ "$DRY_RUN" -eq 0 ]]; then
          set_sync_hash "$item_key" "$(compute_item_hash "$local_item")"
        fi
      fi
    done
  else
    # Handle agents, commands, runbooks (flat .md files)
    for item_file in "$REPO_CAT_DIR"/my-*.md; do
      [[ -f "$item_file" ]] || continue
      item_name=$(basename "$item_file")
      local_item="$LOCAL_CAT_DIR/$item_name"
      item_key="$category/$item_name"

      if [[ ! -f "$local_item" ]]; then
        echo "  + $item_key (new)"
        ((NEW_COUNT++)) || true
        if [[ "$DRY_RUN" -eq 0 ]]; then
          cp "$item_file" "$local_item"
          set_sync_hash "$item_key" "$(compute_item_hash "$local_item")"
        fi
      elif ! diff -q "$item_file" "$local_item" > /dev/null 2>&1; then
        # Items differ — check for conflict
        baseline_hash=$(get_sync_hash "$item_key")
        if [[ -n "$baseline_hash" ]]; then
          local_hash=$(compute_item_hash "$local_item")
          repo_hash=$(compute_item_hash "$item_file")
          local_changed=0
          repo_changed=0
          [[ "$local_hash" != "$baseline_hash" ]] && local_changed=1
          [[ "$repo_hash" != "$baseline_hash" ]] && repo_changed=1

          if [[ "$local_changed" -eq 1 ]] && [[ "$repo_changed" -eq 1 ]]; then
            if [[ "$FORCE" -eq 1 ]]; then
              echo "  ~ $item_key (CONFLICT resolved: --force, repo wins)"
              ((MODIFIED_COUNT++)) || true
              if [[ "$DRY_RUN" -eq 0 ]]; then
                cp "$item_file" "$local_item"
                set_sync_hash "$item_key" "$(compute_item_hash "$local_item")"
              fi
            else
              echo "  X $item_key (CONFLICT: changed locally AND in repo)"
              ((CONFLICT_COUNT++)) || true
            fi
            continue
          fi
        fi
        # No conflict
        echo "  ~ $item_key (modified)"
        ((MODIFIED_COUNT++)) || true
        if [[ "$DRY_RUN" -eq 0 ]]; then
          cp "$item_file" "$local_item"
          set_sync_hash "$item_key" "$(compute_item_hash "$local_item")"
        fi
      else
        ((UNCHANGED_COUNT++)) || true
        log_verbose "  = $item_key (unchanged)"
        if [[ -z "$(get_sync_hash "$item_key")" ]] && [[ "$DRY_RUN" -eq 0 ]]; then
          set_sync_hash "$item_key" "$(compute_item_hash "$local_item")"
        fi
      fi
    done
  fi
done

# Save sync state
save_sync_state "$SYNC_STATE_FILE"

# Summary
echo ""
if [[ "$DRY_RUN" -eq 1 ]]; then
  echo "DRY RUN - No changes made"
  echo "Would update: $NEW_COUNT new, $MODIFIED_COUNT modified, $UNCHANGED_COUNT unchanged"
else
  if [[ "$NEW_COUNT" -eq 0 ]] && [[ "$MODIFIED_COUNT" -eq 0 ]] && [[ "$CONFLICT_COUNT" -eq 0 ]]; then
    echo "Already up to date ($UNCHANGED_COUNT items)"
  else
    echo "Updated: $NEW_COUNT new, $MODIFIED_COUNT modified, $UNCHANGED_COUNT unchanged"
  fi
fi

if [[ "$CONFLICT_COUNT" -gt 0 ]]; then
  echo ""
  echo "CONFLICTS: $CONFLICT_COUNT item(s) changed on both sides."
  echo "  Review manually, then re-run. Or use --force to let repo win."
fi
